## 练习 2.2：

2.2-1 用Θ记号表示函数$n^3/1000-100n^2-100n+3$。
```
Θ(n^3)
```

2.2-2 考虑排序存储在数组A中的n个数：首先找出A中的最小元素并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素并将其与A[2]中的元素进行交换。对A中前n-1个元素按该方式继续。该算法称为选择算法，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前n-1个元素，而不是对所有n个元素运行？用Θ记号给出选择排序的最好情况与最坏情况运行时间。

> 伪代码
```
SELECTION-SORT(A):
    for j = 1 to A.length - 1:
        key = j
        for i = j + 1 to A.length:
            if A[key] > A[i]:
                key = i
        tmp = A[j]
        A[j] = A[key]
        A[key] = tmp        
```

> 循环不变式

A的子数组A[1..j-1]已排序

> 为什么n-1个运行

n-1次运行后，A[1..n-1]包含所有比A[n]小的元素，且已排序。只运行n-1次

> 运行时间

最好：Θ(n^2)

最坏：Θ(n^2)

2.2-3 再次考虑线性查找问题（参见练习2.1-3）。假定要查找的元素等可能地为数组中的任意元素，平均需要检查输人序列的多少元素？最坏情况又如何呢？用Θ记号给出线性查找的
平均情况和最坏情况运行时间。证明你的答案。

> 平均检查

n/2个元素

> 最坏检查

n个

> 运行时间

平均：Θ(n)

最坏：Θ(n)

> 证明

平均：平均来说，A中有一半的元素等于查找值

最坏：数组中不包含找查找值，或者查找值是A中最后一个元素，都比较n次


2.2-4 我们可以如何修改几乎任意算法来使之具有良好的最好情况运行时间？

How can we modify almost any algorithm to have a good best-case running time?

```
方式1. 检查输入是否是预设的特殊情况，如果是，返回准备好的结果；

方式2. 检查输入是否已经解决，如果是，直接返回输入；如排序，可以检查数组A是否已经排序（运行时间Θ(n)），如果已经排序，返回直接返回A；

```