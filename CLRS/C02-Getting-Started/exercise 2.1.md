## 练习 2.1：
2.1-1 以图2-2为模型，说明INSERTION-SORT在数组A=<31,41,59,26,41,58>上的执行过程。
```
a) A[2]与A[1..1]比较，结果为：<31,41,59,26,41,58>
b) A[3]与A[1..2]比较，结果为：<31,41,59,26,41,58>
c) A[4]与A[1..3]比较，结果为：<26,31,41,59,41,58>
d) A[5]与A[1..4]比较，结果为：<26,31,41,41,59,58>
e) A[5]与A[1..4]比较，结果为：<26,31,41,41,58,59>
```

2.1-2 重写过程INSERTION-SORT，使之按非升序（而不是非降序）排序。
```
INSERTION-SORT(A)
    for j = 2 to A.length
        key = A[j]
        i = j -1
        while i > 0 and A[i] < key
            A[i+1] = A[i]
            i = i - 1
        A[i+1] = key    
```

2.1-3 考虑以下查找问题：
输入：n个数的一个序列A=<a1, a2, ..., an>和一个值v。
输出：下标i使得v=A[i]或者当v不在A中出现时，i为特殊值NIL。
写出线性查找的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。
> **伪代码**
```
LIEAR-SEARCH(A, v)
    for i = 1 to A.length
        if A[i] == v
            return i
    return NIL   
```
> **循环不变式**

**循环不变式**：
A的子数组A[1..i-1]不包含v

**初始化**：
第一次迭代初始化之前，即i=1时，子数组A[1..0]为空，不包含v，因此循环不变式成立；

**保持**：
在每次循环中，可知 A[1..i-1]不包含v，比较A[i]与v，如果相等，返回i，正确；如果不等，继续下一次循环。由于A[1..i-1]不包含且A[i]值不等于v，因此在下一次循环前，循环不变式成立；

**终止**：
终止条件有

1. A包含v, 函数返回i，正确；
2. i=A.length+1, 循环不变式为A[1..n]，不包含v，返回NIL，正确；  


2.1-4 考虑把两个n位二进制整数加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数的和应按二进制形式存储在一个(n+1)元数组C中。请给出该问题的形式化描述，并写出伪代码。

> **形式化描述**

**输入**：n个数的序列A=<a1,a2,...,an>和n个数的序列B=<b1,b2,...,bn>, ∀i∈{1..n}: A[i],B[i]∈{1, 0}

**输出**：n-1个数的序列C=<c1,c2,...,cn,cn+1>，满足C'=A'+B',其中A',B',C'为序列A,B,C中值

> **伪代码**
```
BINARY_ADD(A, B)
    C = Array[A.length + 1]
    carry = 0
    for i=1 to A.length
        // 由于元素都非负数，也可以 mod 2 
        C[i] = (A[i] + B[i] + carry) % 2
        carry = (A[i] + B[i] + carry) / 2
    C[i] = carry         
    return C    
```